<!-- Card1 [Êó•-‰∏≠] Ê≠£Èù¢ -->

{{^Alt1}}

<main id="FrontSide" class="CardSide">
  <div class="Top">
    <span class="Level">{{Tags}}</span>
    <a class="Feedback" href="#" target="_blank" onclick="feedback(event)">ÂèçÈ¶à</a>
  </div>

  <header class="Question">
    <div class="VocabAudio">{{VocabAudio}}</div>
    <h1 class="VocabKanji">
      <span lang="ja">{{furigana:VocabKanji}}</span>
      <span class="VocabPitch">{{VocabPitch}}</span>
    </h1>
    <a class="Search" href="#" target="_blank" onclick="lookUp()">üîç</a>
  </header>

  <ul class="SentenceList">
    {{#SentKanji1}}
    <li class="Sentence">
      <h3 class="SentKanji LabelIndent" lang="ja">
        {{#SentFurigana1}}{{kanji:SentFurigana1}}{{/SentFurigana1}}
        {{^SentFurigana1}}{{kanji:SentKanji1}}{{/SentFurigana1}}
      </h3>
    </li>
    {{/SentKanji1}}

    {{#SentKanji2}}
    <li class="Sentence">
      <h3 class="SentKanji LabelIndent" lang="ja">
        {{#SentFurigana2}}{{kanji:SentFurigana2}}{{/SentFurigana2}}
        {{^SentFurigana2}}{{kanji:SentKanji2}}{{/SentFurigana2}}
      </h3>
    </li>
    {{/SentKanji2}}

    {{#SentKanji3}}
    <li class="Sentence">
      <h3 class="SentKanji LabelIndent" lang="ja">
        {{#SentFurigana3}}{{kanji:SentFurigana3}}{{/SentFurigana3}}
        {{^SentFurigana3}}{{kanji:SentKanji3}}{{/SentFurigana3}}
      </h3>
    </li>
    {{/SentKanji3}}

    {{#SentKanji4}}
    <li class="Sentence">
      <h3 class="SentKanji LabelIndent" lang="ja">
        {{#SentFurigana4}}{{kanji:SentFurigana4}}{{/SentFurigana4}}
        {{^SentFurigana4}}{{kanji:SentKanji4}}{{/SentFurigana4}}
      </h3>
    </li>
    {{/SentKanji4}}
  </ul>
</main>

<script>
  function CONFIG() {
    // --- ‰ª•‰∏ã‰∏∫ËÆæÁΩÆÈáåÁöÑÈ¢ÑËÆæÈ°πÔºåÊ†πÊçÆ‰∏™‰∫∫ÈúÄÊ±ÇË∞ÉÊï¥ --- //
    const settings = {
      lang: 'zh-Hans',      // ÊòæÁ§∫ËØ≠Ë®Ä: 'zh-Hans' ÁÆÄ‰Ωì‰∏≠Êñá | 'zh-Hant' ÁπÅ‰Ωì‰∏≠Êñá
      dict: {
        ios: 'moji',        // Âú® iOS ‰ΩøÁî® MOji ËæûÊõ∏
        android: 'moji',    // Âú® Android ‰ΩøÁî® MOji ËæûÊõ∏
        mac: 'dict',        // Âú® macOS ‰ΩøÁî®Á≥ªÁªüËá™Â∏¶ÁöÑËØçÂÖ∏
        win: 'goldendict',  // Âú® Windows ‰ΩøÁî® GoldenDict-ng ËØçÂÖ∏
        other: 'weblio',    // Âú®ÂÖ∂‰ªñÂπ≥Âè∞‰ΩøÁî® Weblio ÂõΩË™ûËæûÂÖ∏
      },
      display: 'default',   // Ê≠£Èù¢ÂçïËØçÊòæÁ§∫: 'default' ÊòæÁ§∫Ê±âÂ≠óÂíåÊ≥®Èü≥ÂÅáÂêç | 'kana' Âè™ÊòæÁ§∫ÂÅáÂêç | 'kanji' Âè™ÊòæÁ§∫Ê±âÂ≠ó
      playback: 'force',    // ËÉåÈù¢Êí≠ÊîæËÆæÁΩÆ: 'default' Ë∑üÈöèÁâåÁªÑÁöÑÁ≥ªÁªüËÆæÁΩÆ | 'force' Âº∫Âà∂Âè™Êí≠ÊîæÂçïËØçÈü≥È¢ë
      tts: {
        enable: 'fallback', // Âú®Á∫ø TTS ÂºÄÂÖ≥: 'always' ÂßãÁªàÂºÄÂêØ | 'fallback' Êó†Êú¨Âú∞Èü≥È¢ëÊó∂ÂêØÁî® | 'never' ÂßãÁªàÂÖ≥Èó≠
        hotkey: 'G',        // Êí≠ÊîæÂø´Êç∑ÈîÆÔºå‰ªÖÊîØÊåÅÊ°åÈù¢Á´Ø
        domain: [
          // ÂèØ‰ª•Ê∑ªÂä†Êõ¥Â§öÂüüÂêçÔºåÊåâÈ°∫Â∫è‰æùÊ¨°Â∞ùËØïÊí≠Êîæ
          'https://anki.0w0.live/',
          'https://ms-ra-forwarder-for-ifreetime-v9q1.vercel.app/',
        ],
        params: {
          voiceName: 'ja-JP-KeitaNeural,ja-JP-NanamiNeural', // ËØ≠Èü≥‰∏∫Â§ö‰∏™Êó∂ÈöèÊú∫ÈÄâÊã©‰∏Ä‰∏™
          speed: -4, // ËØ≠ÈÄüËåÉÂõ¥ -50 Âà∞ 100Ôºå0 ‰∏∫Ê≠£Â∏∏ËØ≠ÈÄü
        }
      }
    }
    // --- ‰ª•‰∏ã‰∏∫ËØçÂÖ∏È¢ÑËÆæÈ°πÔºåÊñ∞Â¢ûËØçÂÖ∏ÂèÇËÄÉÊ†ºÂºèÊ∑ªÂä† --- //
    const dictOptions = {
      'moji': 'mojisho://?search={query}',                          // MOJi ËæûÊõ∏ [ios|android]
      'mojidict': 'https://www.mojidict.com/searchText/{query}',    // MOJi ËæûÊõ∏ÁΩëÈ°µÁâà [web]
      'dict': 'dict://{query}',                                     // macOS ËØçÂÖ∏ [mac]
      'eudic': 'eudic://dict/{query}',                              // Eudic Ê¨ßË∑ØËØçÂÖ∏ [win|mac|ios|android]
      'goldendict': 'goldendict://{query}',                         // GoldenDict-ng ËØçÂÖ∏ [win]
      'dicttango': 'dttp://app.dicttango/WordLookup?word={query}',  // DictTango [android]
      'monokakido': 'mkdictionaries:///?text={query}',              // Monokakido Áâ©Êõ∏Â†Ç [mac|ios]
      'google': 'https://www.google.com/search?q={query}',          // Google Search [web]
      'weblio': 'https://www.weblio.jp/content/{query}',            // Weblio ÂõΩË™ûËæûÂÖ∏ [web]
      'weblioCJJC': 'https://cjjc.weblio.jp/content/{query}',       // Weblio Êó•‰∏≠‰∏≠Êó• [web]
      'takoboto': 'https://takoboto.jp/?q={query}',                 // Takoboto [web]
      'mazii': 'https://mazii.net/zh-TW/search/word/jatw/{query}',  // Mazii [web]
      'jisho': 'https://jisho.org/search/{query}',                  // Jisho [web]
      'kotobank': 'https://kotobank.jp/search?q={query}',           // Kotobank [web]
      'goo': 'https://dictionary.goo.ne.jp/srch/all/{query}/m0u/',  // Goo ËæûÊõ∏ [web]
    }

    return { settings, dictOptions }
  }

  function getTranslation(key) {
    const translations = {
      feedback: {
        'zh-Hans': 'ÂèçÈ¶à',
        'zh-Hant': 'ÂèçÈ•ã',
      },
      dictionaryTip: {
        'zh-Hans': 'Êú™ÈÖçÁΩÆÈÄÇÁî®‰∫éÊ≠§Âπ≥Âè∞ÁöÑËØçÂÖ∏',
        'zh-Hant': 'Êú™ÈÖçÁΩÆÈÅ©Áî®ÊñºÊ≠§Âπ≥Âè∞ÁöÑË©ûÂÖ∏',
      },
      updateReminder: {
        'zh-Hans': 'ËØ∑Êõ¥Êñ∞Ëá≥ÊúÄÊñ∞ÁâàÂêéÂÜçÊèê‰∫§ÂèçÈ¶à',
        'zh-Hant': 'Ë´ãÊõ¥Êñ∞Ëá≥ÊúÄÊñ∞ÁâàÂæåÂÜçÊèê‰∫§ÂèçÈ•ã',
      },
      versionCurrent: {
        'zh-Hans': 'ÂΩìÂâçÁâàÊú¨',
        'zh-Hant': 'Áï∂ÂâçÁâàÊú¨',
      },
      versionLatest: {
        'zh-Hans': 'ÊúÄÊñ∞ÁâàÊú¨',
        'zh-Hant': 'ÊúÄÊñ∞ÁâàÊú¨',
      },
      updateDetails: {
        'zh-Hans': 'Êõ¥Êñ∞ËØ¥Êòé',
        'zh-Hant': 'Êõ¥Êñ∞Ë™™Êòé',
      }
    }
    const lang = CONFIG().settings.lang
    return translations[key]?.[lang] || ''
  }

  function getToday() {
    return new Date().toLocaleDateString('sv-SE')
  }

  function setStorage(value) {
    Object.keys(localStorage)
      .filter(key => key.startsWith('JLPT_'))
      .forEach(key => localStorage.removeItem(key))
    const key = `JLPT_${getToday()}`
    localStorage.setItem(key, JSON.stringify(value))
  }

  function getStorage() {
    const key = `JLPT_${getToday()}`
    return JSON.parse(localStorage.getItem(key)) || {}
  }

  function getCurrentVersion(tags = '{{Tags}}') {
    return tags.split(/\s+|::/).find(part => part.startsWith('v')) || ''
  }

  async function getLatestReleaseInfo() {
    let latest, info
    try {
      const response = await fetch('https://api.github.com/repos/5mdld/anki-jlpt-decks/releases/latest')
      if (!response.ok) throw new Error(response.status)

      const data = await response.json()
      latest = `v${data.tag_name?.split('_')[0].replace(/^v/, '')}`
      info = data.body?.replace(/\r?\n/g, '<br>')
        .replace(/`(.*?)`/g, '<code>$1</code>')
        .replace(/(\s+)-/g, '$1‚ó¶')
        .replace(/-/g, '‚ñ™')
    } catch (err) {
      console.error(err)
    }
    return { latest, info }
  }

  function createDialog(config = {}) {
    if (document.getElementById('DynamicDialog')) {
      closeDialog()
    }
    const modal = document.createElement('div')
    modal.id = 'DynamicDialog'
    modal.className = 'DialogOverlay'
    modal.innerHTML = `
    <div class="DialogContent">
      <h2 class="DialogTitle">${config.title || 'ÊèêÁ§∫'}</h2>
      <div class="DialogBody">${config.content || ''}</div>
      <div class="DialogFooter">
        ${config.cancelText ? `<a href="#" target="_blank" class="DialogButton CancelButton">${config.cancelText}</a>` : ''}
        <a href="#" target="_blank" class="DialogButton ConfirmButton">${config.confirmText || 'Á°ÆÂÆö'}</a>
      </div>
    </div>
    `
    modal.querySelector('.DialogContent').addEventListener('click', e => e.stopPropagation())
    modal.querySelector('.CancelButton')?.addEventListener('click', e => { e.preventDefault(); (config.onCancel || closeDialog)() })
    modal.querySelector('.ConfirmButton').addEventListener('click', config.onConfirm || closeDialog)
    modal.addEventListener('click', closeDialog)
    document.getElementById('qa').appendChild(modal)
    document.body.style.overflow = 'hidden'
  }

  function closeDialog() {
    document.getElementById('DynamicDialog')?.remove()
    document.body.style.overflow = ''
  }

  async function checkVersion(force = false) {
    const current = getCurrentVersion()
    const storage = getStorage()
    const el = document.querySelector('.Feedback')

    const shouldFetch = force || (current && !storage.latest?.startsWith?.('v'))
    const { latest, info } = shouldFetch ? await getLatestReleaseInfo().then(res => (setStorage(res), res)) : storage

    const icon = el.querySelector('i')
    if (current && latest && current !== latest) {
      if (!icon) {
        el.insertAdjacentHTML('afterbegin', '<i>üéâ </i>')
      }
    } else {
      icon?.remove()
    }
    return { current, latest, info }
  }

  async function feedback(e) {
    const current = getCurrentVersion()
    const { latest, info } = await checkVersion(!current)

    if (!current || current !== latest) {
      e.preventDefault()
      createDialog({
        title: `
        <p>üéâ ÂèØÁî®Êõ¥Êñ∞</p>
        <span>${getTranslation('updateReminder')}</span>
        `,
        content: `
        <p>üìå ${getTranslation('versionCurrent')}: ${current || 'Unknown'}</p>
        <p>üåü ${getTranslation('versionLatest')}: ${latest || 'Unknown'}</p>
        <p>üöÄ ${getTranslation('updateDetails')}: </p>
        <ul>${info || '- No details available'}</ul>
        `,
        cancelText: 'ÂèñÊ∂à',
        confirmText: 'Êõ¥Êñ∞',
        onConfirm: () => {
          document.querySelector('a.ConfirmButton').href = 'https://github.com/5mdld/anki-jlpt-decks/releases/latest'
          closeDialog()
        }
      })
    } else {
      document.querySelector('a.Feedback').href = getFeedbackLink()
    }
  }

  function getFeedbackLink(platform = 'github', VocabKanji = '{{text:kanji:VocabKanji}}', NoteID = '{{text:NoteID}}') {
    const current = getCurrentVersion()
    const urls = {
      github: `https://github.com/5mdld/anki-jlpt-decks/issues/new?${new URLSearchParams({
        title: `[Âç°ÁâáÂèçÈ¶à] ${getToday()} „Äå${VocabKanji}„Äç`,
        body: `### Âç°Áâá‰ø°ÊÅØ\n- Âç°ÁâáÁâàÊú¨: ${current}\n- VocabKanji: ${VocabKanji}\n- NoteID: ${NoteID}\n\n### ÂèçÈ¶àÂÜÖÂÆπ\n`,
      })}`,
      feishu: `https://ncn8ci2h7v0y.feishu.cn/share/base/form/shrcnTh5DRxtrGWtiWTkdBlSWze?${new URLSearchParams({
        NoteID,
        Version: current
      })}`,
    }
    return urls[platform]
  }

  function getPlatform() {
    return ['ios', 'android', 'mac', 'win'].find(p => document.documentElement.className.includes(p)) || 'other'
  }

  function isAndroid() {
    return !!document.documentElement.className.includes('android')
  }

  function isBackSide() {
    return !!document.getElementById('BackSide')
  }

  function cleanWord(word) {
    return word.replace(/\[[^\]]*\]|\([^)]*\)|[0-9!@#$%^&*()_+\-='":\\|,.<>/?~ÔΩû„Äú\s]+/g, '')
  }

  function lookUp(word = '{{text:VocabKanji}}') {
    const cleaned = cleanWord(word)
    const dict = CONFIG().settings.dict[getPlatform()]
    const scheme = CONFIG().dictOptions[dict]
    if (!scheme) {
      createDialog({
        content: `<p class="text-center">${getTranslation('dictionaryTip')}</p>`,
        cancelText: 'ÂèñÊ∂à',
        confirmText: 'Êü•ÁúãÊñáÊ°£',
        onConfirm: () => {
          document.querySelector('a.ConfirmButton').href = 'https://github.com/5mdld/anki-jlpt-decks/blob/main/README.md'
          closeDialog()
        }
      })
    }
    const url = scheme.replace('{query}', encodeURIComponent(cleaned))
    document.querySelector('a.Search').href = url
  }

  function forcePlayback() {
    if (CONFIG().settings.playback !== 'force') return
    const el = document.querySelector('.VocabAudio .replay-button')
    if (el) el.click()
  }

  function hideFrontElements() {
    document.querySelector('#FrontSide ul').style.display = 'none'
  }

  function hideFurigana() {
    if (CONFIG().settings.display === 'kanji') {
      document.querySelectorAll('.VocabKanji rt').forEach(rt => {
        rt.style.display = isBackSide() ? 'ruby-text' : 'none'
      })
    }
  }

  function hideKanji() {
    if (CONFIG().settings.display === 'kana') {
      if (isBackSide()) {
        if (isAndroid()) {
          updateText('.VocabKanji span[lang="ja"]', '{{furigana:VocabKanji}}')
        }
        return
      }
      const isKatakana = getTags().includes('Â§ñ') || /^[„Ç°-„É¥„Éº]+$/.test('{{VocabKanji}}')
      updateText('.VocabKanji span[lang="ja"]', isKatakana ? '{{kanji:VocabKanji}}' : '{{VocabFurigana}}')
    }
  }

  function audioStylePatch() {
    const target = document.querySelector('#FrontSide .VocabAudio')
    const source = document.querySelector('#qa > .VocabAudio')
    if (source && target && !target.innerHTML.trim()) {
      source.classList.remove('!hidden')
      target.replaceWith(source)
    }
  }

  function updateText(selector, text) {
    if (!text) return
    const el = document.querySelector(selector)
    if (el) {
      isAndroid() || el.innerHTML.includes('<ruby>')
        ? el.innerHTML = text
        : el.textContent = text
    }
  }

  function getTags(tags = '{{Tags}}') {
    const ignore = ['$', '^', 'v']
    return tags.split(/\s+/)
      .map(tag => tag.split(/::|-/).pop())
      .filter(tag => !ignore.some(prefix => tag.startsWith(prefix)))
      .sort((a, b) => b.startsWith('N') - a.startsWith('N') || a.localeCompare(b))
      .join('„Éª')
  }

  function setLang() {
    updateText('.Level', getTags())
    updateText('.Feedback', getCurrentVersion() ? `${getCurrentVersion()}„Éª${getTranslation('feedback')}` : getTranslation('feedback'))
    const lang = CONFIG().settings.lang
    if (lang === 'zh-Hant') {
      document.documentElement.lang = lang
      updateText('.VocabDef', '{{VocabDefTC}}')
      const defs = ['{{SentDefTC1}}', '{{SentDefTC2}}', '{{SentDefTC3}}', '{{SentDefTC4}}']
      defs.forEach((def, index) => updateText(`li:nth-child(${index + 1}) .SentDef`, def))
    }
    checkVersion()
  }

  function removeSpaces() {
    document.querySelectorAll('.VocabPlus, .VocabPoS, .SentKanji, .SentFurigana, .SentDef').forEach(el => {
      el.innerHTML = el.innerHTML
        .replace(/\s*\n\s*/g, '')
        .replace(/>\s+</g, '><')
        .replace(/(<[^>]+>)|\s+/g, (m, tag) => tag || '')
    })
  }

  function toggleBlur() {
    document.querySelectorAll('.VocabKanji, .VocabFurigana, .VocabPlus, .SentKanji').forEach(el =>
      el.classList.toggle('blur')
    )
  }

  function getType(index) {
    return ['{{SentType1}}', '{{SentType2}}', '{{SentType3}}', '{{SentType4}}'][index] || '‰æã'
  }

  function setType() {
    ['.SentKanji', '.SentFurigana', '.SentDef', '.VocabPlus', '.VocabPoS'].forEach(selector => {
      document.querySelectorAll(selector).forEach((el, i) => {
        if (!el.textContent.trim() || el.querySelector('em')) return
        const typeMap = {
          'SentDef': 'ÔºªË®≥ÔºΩ',
          'VocabPlus': 'ÔºªË£úÔºΩ',
          'SentKanji': `Ôºª${getType(i)}ÔºΩ`,
          'SentFurigana': `Ôºª${getType(i)}ÔºΩ`,
          'VocabPoS': '{{VocabPoS}}' ? 'Ôºª{{VocabPoS}}ÔºΩ' : 'ÔºªÂêçÔºΩ',
        }
        const type = typeMap[Object.keys(typeMap).find(key => el.className.includes(key))]
        el.insertAdjacentHTML('afterbegin', `<em lang='ja'>${type}</em>`)
      })
    })
  }

  function markWords(word = '{{text:VocabKanji}}') {
    const wordRegex = /[‰∏Ä-Èæ†„ÄÖ„Éµ„É∂]+|[„ÅÅ-„Çì„Ç°-„É¥„Éº]+/g
    const kanjiRegex = /[‰∏Ä-Èæ†„ÄÖ„Éµ„É∂]/
    const parts = cleanWord(word).match(wordRegex) ?? []
    const regexParts = parts.map(part => {
      return kanjiRegex.test(part)
        ? `(?:<ruby><rb>${part}</rb><rt>[^<]+</rt></ruby>|${part})`
        : `(?:<ruby><rb>[^<]+</rb><rt>${part}</rt></ruby>|${part})`
    })
    const regex = new RegExp(regexParts.join('(?:\\s*?)'), 'g');

    ['.SentKanji', '.SentFurigana'].forEach(selector => {
      document.querySelectorAll(selector).forEach((el, i) => {
        const type = getType(i)
        if (el.querySelector('b, i, u, span, strong') || type !== '‰æã') return
        el.innerHTML = el.innerHTML
          .replace(regex, match => `<strong>${match}</strong>`)
          .replace(/[ÔΩû„Äú]/g, `<strong>${cleanWord(word)}</strong>`)
      })
    })
  }

  function highlightWords() {
    document.querySelectorAll('.SentFurigana').forEach((el, i) => {
      if (el.querySelector('b, i, u, span')) return
      const type = getType(i)
      const prefix = type.match(/^(Èñ¢|ÂØæ)/)
      if (!prefix) return
      const tag = prefix[1] === 'Èñ¢' ? 'synonym' : 'antonym'
      const content = el.innerHTML
        .replace(/^<em[^>]*>Ôºª[^]*?ÔºΩ<\/em>/, '')
        .trim()
        .replace(/^Ôºª[^]*?ÔºΩ/, '')
      el.innerHTML = el.querySelector('em') ? `<em lang='ja'>Ôºª${type}ÔºΩ</em><span class='${tag}'>${content}</span>` : `<span class='${tag}'>${content}</span>`
    })
  }

  function showHint() {
    if (isBackSide()) {
      document.querySelectorAll('a.hint').forEach(hint => hint.style.display = 'none')
    }
  }

  function setAnkiWebAudio() {
    if (!document.getElementById('quiz')) return

    document.querySelectorAll('.VocabAudio, .SentAudio').forEach(el => {
      const audio = el.querySelector('audio')
      if (!audio) return
      audio.removeAttribute('controls')
      el.insertAdjacentHTML('beforeend', '<a class="replay-button soundLink"><svg viewBox="0 0 64 64"><circle cx="32" cy="32" r="29"/><path d="M56.502,32.301l-37.502,20.101l0.329,-40.804l37.173,20.703Z"/></svg></a>')
      el.querySelector('.replay-button').addEventListener('click', e => {
        e.preventDefault()
        document.querySelectorAll('audio').forEach(a => a !== audio && !a.paused && a.pause())
        audio.currentTime = 0
        audio.play()
      })
    })
  }

  function setEdgeTTS() {
    const { enable, hotkey, domain, params } = CONFIG().settings.tts
    if (enable === 'never') return

    const getVoice = () => {
      const voices = params.voiceName.split(',').map(v => v.trim())
      return voices.length === 1 ? voices[0] : voices[Math.floor(Math.random() * voices.length)]
    }
    const getSentKanji = (index) => {
      const SentKanji = [
        '{{text:kanji:SentKanji1}}',
        '{{text:kanji:SentKanji2}}',
        '{{text:kanji:SentKanji3}}',
        '{{text:kanji:SentKanji4}}'
      ][index] || ''
      return SentKanji.replace(/„Éª/g, '„ÄÅ')
    }
    document.querySelectorAll('.SentAudio').forEach((el, i) => {
      if (enable === 'fallback' && el.childNodes.length) return
      const text = getSentKanji(i)
      if (!text) return
      const queryString = new URLSearchParams({ ...params, text, voiceName: getVoice() })
      const audio = document.createElement('audio')
      audio.preload = 'none'
      domain.forEach(url => {
        const source = document.createElement('source')
        source.src = `${url}api/aiyue?${queryString}`
        source.type = 'audio/mpeg'
        audio.appendChild(source)
      })
      el.appendChild(audio)
      el.insertAdjacentHTML(
        'beforeend',
        '<a class="tts replay-button soundLink"><svg viewBox="0 0 64 64"><circle cx="32" cy="32" r="29"/><path d="M56.502,32.301l-37.502,20.101l0.329,-40.804l37.173,20.703Z"/></svg></a>',
      )
      el.querySelector('.tts.replay-button').addEventListener('click', e => {
        e.preventDefault()
        document.querySelectorAll('audio').forEach(a => a !== audio && !a.paused && a.pause())
        audio.currentTime = 0
        audio.play()
      })
    })
    triggerAudioPlayback(hotkey)
  }

  function triggerAudioPlayback(hotkey) {
    if (!hotkey) return

    let currentAudioIndex = 0
    let isError = false
    document.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === hotkey.toLowerCase()) {
        const audios = document.querySelectorAll('.CardSide audio')
        audios.forEach((audio) => {
          audio.pause()
          audio.currentTime = 0
        })
        if (!isError) currentAudioIndex = 0
        playNext(audios)
      }
    })
    function playNext(audios) {
      if (currentAudioIndex >= audios.length) return
      const audio = audios[currentAudioIndex]
      audio.play().then(() => {
        audio.onended = () => {
          currentAudioIndex++
          playNext(audios)
        }
        isError = false
      }).catch(() => (isError = true))
    }
  }
</script>

<script>
  setLang()
  setType()
  markWords()
  removeSpaces()
  setAnkiWebAudio()
  hideFurigana()
  hideKanji()
</script>

{{/Alt1}}